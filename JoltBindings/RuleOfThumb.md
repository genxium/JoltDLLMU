# Cross-runtime Alloc/Dealloc

1. If an unmanaged heap object is created from C#, it must be destroyed by C#, e.g. reusable Colliders/Bodies, Constraints created from RoomDownsyncFrame; 
2. If an unmanaged heap object is created from C++, it must be destroyed by C++, e.g. transient Contacts/ContactManifold instances created from "Step(...)" for collision callback. 

# About lost of zero-alloc/dealloc from DLLMU-v2.3.4

"Battle.Step()" is no longer zero-alloc/dealloc compared to [DLLMU-v2.3.4](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/Battle_dynamics.cs#L2218), but it's good enough due to the tricks explained in [this note](https://www.yinxiang.com/everhub/note/9ec5cb4f-37ff-4da5-a3d5-123958b9b2ec?source=details), by this little disadvantage it removed the need to use fixed battle region/bounds.

# About "Contact" and "ContactConstraint" 

- Conceptually, one must find a `Contact` before adding a `ContactConstraint` to the math-solver for later processing.
    - [DLLMU-v2.3.4](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/Battle_dynamics.cs) has no equivalent concepts while the closest analogy to "[CollideShapeResult](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/CollideShape.h#L18) -> [ContactManifold](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/ContactListener.h#L19)" is "[SatResult](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/resolv/ColliderShape.cs#L234) -> `hardPushback & softPushback`", i.e. both after NarrowPhase collision information extraction. Yet without use of any math-solver the analogy is negligible.
    - Kindly note that none of [class CollideShapeResult](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/CollideShape.h#L18), [class ContactManifold](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/ContactListener.h#L19) or [class ContactConstraint](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.h#L441) is a `RefTarget<>`.

- Before diving into Jolt's implementation, the following should be true for all Physics Engines.
    - At the beginning of each "world.Update(dt)", all previously used contact information should NOT impact result of the current update, regardless of whether or not we use it in a rollback netcode. Kindly note that none of `class CollideShapeResult`, `class ContactManifold` or `class ContactConstraint` is a `RefTarget<>`.
    - The Physics Engine must implicitly handle all `non-penetration constraints` in each "world.Update(dt)" anyway regardless of whether or not any user callback is registered. **It's possible to hold all non-penetration two-body-pairs in memory simultaneously for the math-solver because those are often having a collection size of O( bodiesCount ), NOT O( bodiesCount^2 )**.
    - On the otherhand, it's impossible for "world.Update(dt)" to hold all types of two-body-pairs in memory simultaneously, consider just 20,000 crowded/overlapping bodies which could easily crash memory if all two-body-pairs cached.
    - According to the above, it seems natural to emit collision callback upon the implicit handling of "penetrable" two-body-pairs to save some memory -- however with this approach the order of custom handling might be random, impacting determinism. [Erin Catto (author of Box2D) has a blog about this topic, pointing out that the Parallel Union-Find algorithm used by Jolt might suffer from either non-determinism or performance degradation issues by using sort](https://box2d.org/posts/2023/10/simulation-islands/).

- Now specific to Jolt's implementation, it creates [ContactConstraint](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.h#L441) by `ContactConstraintManager.AddContactConstraint` [here](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1172) and [here](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1244). The callstack is basically
    - [Update](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L132) calls
      - [JobFindCollisions](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L269) if `PhysicsUpdateContext::Step.mBodyPairQueues[mJobIndex]` is full then calls
        - [ProcessBodyPair](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L885), calls
          - [mSimCollideBodyVsBody with `ReductionCollideShapeCollector collector`](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1159), which defaults to [sDefaultSimCollideBodyVsBody](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L968) where each [`sCollideShape[i][j]`](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/CollisionDispatch.cpp#L12) [function-pointer](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/CollisionDispatch.h#L72) is registered via implementation classes such as [ConvexShape](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/ConvexShape.cpp#L561), and
          - each `CollideShapeResult` is translated into a `ContactManifold` by [merging](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1108) or [replacing](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1131) or [inserting](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1136) in `collector.mManifolds`, and 
          - each `ContactManifold` is [translated into a `ContactConstraint`](https://github.com/jrouwe/JoltPhysics/blob/master/Jolt/Physics/Constraints/ContactConstraintManager.cpp#L1126) by [mContactManager->AddContactConstraint](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1172), and 
          - [mIslandBuilder.LinkBodies](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/PhysicsSystem.cpp#L1278)
- The very key variable `CollideShapeResult` is created in a `XxxShape v.s. XxxShape` dependent manner, most notably [Convex v.s. Convex](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/ConvexShape.cpp#L45), here comes some similarity to [DLLMU-v2.3.4 SatResult calculation](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/Battle_geometry.cs#L66), where the `penetration_axis` is 
    - [first guessed to be center of mass difference between shape1 and shape2](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/ConvexShape.cpp#L72)
    - [then corrected by GJK algorithm](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/ConvexShape.cpp#L93)
    - [then corrected again by EPA algorithm](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/ConvexShape.cpp#L127)  

- Finally about the solver for `non-penetration constraints`. 
    - For a rigid body, its `shape`, `mass` and `inertia tensor` should NOT change when resolving any constraint.
    - Like in DLLMU-v2.3.4, all structures of [CollideShapeResult](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/CollideShape.h#L18), [ContactManifold](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/ContactListener.h#L19) and [ContactConstraint](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.h#L441) suggest that any `non-penetration constraint` of a two-body-pair only contains 1 `penetration_axis` (most likely the norm of the support face of body2 after GJK and EPA removed unfit candidates).
    - When a `ContactConstraint` is created upon collision it hass already been violated to some extent, i.e. [WorldContactPoints ContactConstraint.mContactPoints](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.h#L472) is a cache of such violation to be later solved \[[1](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.cpp#L1624), [2](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.cpp#L1747)\]. 
        - In DLLMU-v2.3.4 I only relentlessly set the `penetration_depth` to a prescribed value upon detection of any penetration by [removing unfits and merging hard/soft pushbacks for `effPushback`](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/Battle_dynamics.cs#L1448) and [feeding the results into `_processEffPushbacks`](https://github.com/genxium/DelayNoMoreUnity/blob/v2.3.4/shared/Battle_dynamics.cs#L1847) -- without any `Constraint Island` grouping and grouped solver.
        - Both Box2D and Jolt solve `non-penetration constraints` using [sequential impulse](../references/ConstraintSolverImpulses.pdf). However, [Jolt's underlying velocity constraint handling is empty for non-Dynamic motion type bodies](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ConstraintPart/AxisConstraintPart.h#L46) in [AxisConstraintPart WorldContactPoint.mNonPenetrationConstraint](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ContactConstraintManager.h#L430), i.e. the whole solver falls back to only [positioning correction](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Constraints/ConstraintPart/AxisConstraintPart.h#L554) as the aforementioned DLLMU-v2.3.4 approach.

# On the reuse pattern of `Body`, `Shape` and `ShapeSettings`

As described above, the collision of `Body` instances are done via [Body.GetTransformedShape()](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/NarrowPhaseQuery.cpp#L255) w.r.t. body specific properties instead of the immutable `Body.mShape` (`class Shape` itself is immutable, i.e. [has no setter method or public member](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Collision/Shape/Shape.h)), therefore when trying to reuse a `Body cachedBody` instance with a different shape (either different type or different shape-specific parameters), we should
- if an `XxxShapeSettings*` instance with same shape-subtype and same parameters already exists in `shapeSettingsCache`, use cached value to assign `newShapeSettings`, otherwise
- create a `XxxShapeSettings* newShapeSettings` and `shapeSettingsCache.insert(newShapeSettings)`, then
- `cachedBody.SetShape(newShapeSettings)` which automatically decreases `cachedBody.mShape.mRefCount of the oldShape`.

Don't forget to delete all cached `XxxShapeSettings*` instances at the end of a battle -- kindly note that as [class Body](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Body/Body.h) doesn't hold any reference to `class ShapeSettings` or to `class BodyCreationSettings` (the method [Body.GetBodyCreationSettings](https://github.com/jrouwe/JoltPhysics/blob/v5.3.0/Jolt/Physics/Body/Body.cpp#L330) creates a temporary one on the fly), we're free to choose how to manage the heap-memory lifecycle.
